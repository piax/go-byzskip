// In order to re-generate the golang packages for `Message` you will need...
// protoc -I. --go_out=. ayame.proto
//
// Old:
// 1. Protobuf binary (tested with protoc 3.17.3)
// 2. protoc-gen-gofast binary - go get github.com/gogo/protobuf/protoc-gen-gofast
// protoc --gofast_out=. ayame.proto

syntax = "proto3";
package ayame.pb;
option go_package = "./";
import "github.com/libp2p/go-libp2p-record/pb/record.proto";

enum KeyType {
	INT = 0;
	FLOAT = 1;
	STRING = 2;
    ID = 3;
    RANGE = 4;
    UNIFIED = 5;
}

message Cert {
    int64 validAfter = 1;
    int64 validBefore = 2;
    bytes sig = 3;
}

message Key {
    KeyType type = 1;
    bytes body = 2;
}

message Range {
    Key start = 1;
    bool start_inclusive = 2;
    Key startExtent = 3;
    Key end = 4;
    bool end_inclusive = 5;
    Key endExtent = 6;
}

enum ConnectionType { // 
	// sender does not have a connection to peer, and no extra information (default)
	NOT_CONNECTED = 0;

	// sender has a live connection to peer
	CONNECTED = 1;

	// sender recently connected to peer
	CAN_CONNECT = 2;

	// sender recently tried to connect to peer repeatedly but failed to connect
	// ("try" here is loose, but this should signal "made strong effort, failed")
	CANNOT_CONNECT = 3;
}

enum MessageType {
	PUT_VALUE = 0;
	GET_VALUE = 1;
    ADD_PROVIDER = 2;
    GET_PROVIDERS = 3;
	FIND_NODE = 4;
    FIND_MV = 5;
    FIND_RANGE = 6;
	PING = 7;
    DEL_NODE = 8;
    UNICAST = 9;
    MULTICAST = 10;
}

// Sender information
message Peer {
    // id of node =base58(multihash(nodePubKey))
    string id = 1; 
    // multiaddrs for a given peer
    repeated bytes addrs = 2;
    // used to signal the sender's connection capabilities to the peer
    ConnectionType connection = 3;
    // the key to join to the overlay
    Key key = 4;
    // the membership vector to join the overlay
    bytes mv = 5;
    // certificate information (=a signature for id,key,mv)
    bytes cert = 6;
}

// import libp2p-record
//message Record {
        // The key that references this record
//        bytes key = 1;

        // The actual value this record is storing
//        bytes value = 2;

        // Note: These fields were removed from the Record message
        // hash of the originators public key
        //optional string originator = 3;
        // A PKI signature for the key+value+originator
        //optional bytes signature = 4;

        // Time the record was received, set by receiver
//        string timeReceived = 5;
//}

message TableIndex {
    int32 level = 1;
    Key min = 2;
    Key max = 3;
}

message FindNodeRequest {
    Key key = 1;
    bytes MV = 2;
    TableIndex closestIndex = 3;
    repeated TableIndex neighborListIndex = 4;
}

// designed to be used in all protocols
message MessageData {
    string version = 1;      // version information
    MessageType type = 2;
    int64 timestamp = 3;     // The time when the message was originated
    string id = 4;           // the message identifier

    FindNodeRequest req = 5;

    // Used to specify the key associated with this message (may be a range in multicast)
    Key key = 6;

    // Used to specify the MV associated with this message
    bytes mv = 7;

    // protocol specific data added by originator (such as level info)
    string originatorAppData = 8;

    // peer information of the node who created the message 
    Peer originator = 9;    // XXX ConnectionType is always CONNECTED for node itself
    // the Secp256k1 public key (32bytes)
    bytes originatorPubKey = 10;

    // signature of message by originator node (except originatorSign and senderAppData)
    bytes originatorSign = 11;
    // protocol specific data added by sender (such as level info)
    string senderAppData = 12;

    // Used to return peers closer to a key in FIND_NODE
    repeated Peer closerPeers = 13;
    // Used to include candidate peers in FIND_NODE
    repeated Peer candidatePeers = 14;

    // used to include path in UNICAST
    repeated Peer path = 15;

    // the record used to deliver in this message
    repeated Record record = 16;
}

message Message {
    MessageData data = 1;
    // signature of message by sender node
    bytes senderSign = 2;
    // peer information of the node who sent the message
    Peer sender = 3;
    bool isRequest = 4;  // true if message is a request (requires response)
    bool isResponse = 5;  // true if message is the response
}
