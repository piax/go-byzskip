// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ayame.proto

package ayame_pb

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type KeyType int32

const (
	KeyType_INT     KeyType = 0
	KeyType_FLOAT   KeyType = 1
	KeyType_STRING  KeyType = 2
	KeyType_ID      KeyType = 3
	KeyType_RANGE   KeyType = 4
	KeyType_UNIFIED KeyType = 5
)

var KeyType_name = map[int32]string{
	0: "INT",
	1: "FLOAT",
	2: "STRING",
	3: "ID",
	4: "RANGE",
	5: "UNIFIED",
}

var KeyType_value = map[string]int32{
	"INT":     0,
	"FLOAT":   1,
	"STRING":  2,
	"ID":      3,
	"RANGE":   4,
	"UNIFIED": 5,
}

func (x KeyType) String() string {
	return proto.EnumName(KeyType_name, int32(x))
}

func (KeyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7b4b639837d62b3e, []int{0}
}

type ConnectionType int32

const (
	// sender does not have a connection to peer, and no extra information (default)
	ConnectionType_NOT_CONNECTED ConnectionType = 0
	// sender has a live connection to peer
	ConnectionType_CONNECTED ConnectionType = 1
	// sender recently connected to peer
	ConnectionType_CAN_CONNECT ConnectionType = 2
	// sender recently tried to connect to peer repeatedly but failed to connect
	// ("try" here is loose, but this should signal "made strong effort, failed")
	ConnectionType_CANNOT_CONNECT ConnectionType = 3
)

var ConnectionType_name = map[int32]string{
	0: "NOT_CONNECTED",
	1: "CONNECTED",
	2: "CAN_CONNECT",
	3: "CANNOT_CONNECT",
}

var ConnectionType_value = map[string]int32{
	"NOT_CONNECTED":  0,
	"CONNECTED":      1,
	"CAN_CONNECT":    2,
	"CANNOT_CONNECT": 3,
}

func (x ConnectionType) String() string {
	return proto.EnumName(ConnectionType_name, int32(x))
}

func (ConnectionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7b4b639837d62b3e, []int{1}
}

type MessageType int32

const (
	MessageType_PUT_VALUE     MessageType = 0
	MessageType_GET_VALUE     MessageType = 1
	MessageType_ADD_PROVIDER  MessageType = 2
	MessageType_GET_PROVIDERS MessageType = 3
	MessageType_FIND_NODE     MessageType = 4
	MessageType_FIND_MV       MessageType = 5
	MessageType_PING          MessageType = 6
	MessageType_DEL_NODE      MessageType = 7
	MessageType_UNICAST       MessageType = 8
	MessageType_MULTICAST     MessageType = 9
)

var MessageType_name = map[int32]string{
	0: "PUT_VALUE",
	1: "GET_VALUE",
	2: "ADD_PROVIDER",
	3: "GET_PROVIDERS",
	4: "FIND_NODE",
	5: "FIND_MV",
	6: "PING",
	7: "DEL_NODE",
	8: "UNICAST",
	9: "MULTICAST",
}

var MessageType_value = map[string]int32{
	"PUT_VALUE":     0,
	"GET_VALUE":     1,
	"ADD_PROVIDER":  2,
	"GET_PROVIDERS": 3,
	"FIND_NODE":     4,
	"FIND_MV":       5,
	"PING":          6,
	"DEL_NODE":      7,
	"UNICAST":       8,
	"MULTICAST":     9,
}

func (x MessageType) String() string {
	return proto.EnumName(MessageType_name, int32(x))
}

func (MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7b4b639837d62b3e, []int{2}
}

type Key struct {
	Type                 KeyType  `protobuf:"varint,1,opt,name=type,proto3,enum=ayame.pb.KeyType" json:"type,omitempty"`
	Body                 []byte   `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Key) Reset()         { *m = Key{} }
func (m *Key) String() string { return proto.CompactTextString(m) }
func (*Key) ProtoMessage()    {}
func (*Key) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b4b639837d62b3e, []int{0}
}
func (m *Key) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Key) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Key.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Key) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Key.Merge(m, src)
}
func (m *Key) XXX_Size() int {
	return m.Size()
}
func (m *Key) XXX_DiscardUnknown() {
	xxx_messageInfo_Key.DiscardUnknown(m)
}

var xxx_messageInfo_Key proto.InternalMessageInfo

func (m *Key) GetType() KeyType {
	if m != nil {
		return m.Type
	}
	return KeyType_INT
}

func (m *Key) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

// Sender information
type Peer struct {
	// id of node =base58(multihash(nodePubKey))
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// multiaddrs for a given peer
	Addrs [][]byte `protobuf:"bytes,2,rep,name=addrs,proto3" json:"addrs,omitempty"`
	// used to signal the sender's connection capabilities to the peer
	Connection ConnectionType `protobuf:"varint,3,opt,name=connection,proto3,enum=ayame.pb.ConnectionType" json:"connection,omitempty"`
	// the key to join to the overlay
	Key *Key `protobuf:"bytes,4,opt,name=key,proto3" json:"key,omitempty"`
	// the membership vector to join the overlay
	Mv []byte `protobuf:"bytes,5,opt,name=mv,proto3" json:"mv,omitempty"`
	// certificate information (=a signature for id,key,mv)
	Cert                 []byte   `protobuf:"bytes,6,opt,name=cert,proto3" json:"cert,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Peer) Reset()         { *m = Peer{} }
func (m *Peer) String() string { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()    {}
func (*Peer) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b4b639837d62b3e, []int{1}
}
func (m *Peer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Peer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Peer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Peer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Peer.Merge(m, src)
}
func (m *Peer) XXX_Size() int {
	return m.Size()
}
func (m *Peer) XXX_DiscardUnknown() {
	xxx_messageInfo_Peer.DiscardUnknown(m)
}

var xxx_messageInfo_Peer proto.InternalMessageInfo

func (m *Peer) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Peer) GetAddrs() [][]byte {
	if m != nil {
		return m.Addrs
	}
	return nil
}

func (m *Peer) GetConnection() ConnectionType {
	if m != nil {
		return m.Connection
	}
	return ConnectionType_NOT_CONNECTED
}

func (m *Peer) GetKey() *Key {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Peer) GetMv() []byte {
	if m != nil {
		return m.Mv
	}
	return nil
}

func (m *Peer) GetCert() []byte {
	if m != nil {
		return m.Cert
	}
	return nil
}

type Record struct {
	// The key that references this record
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// The actual value this record is storing
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// Time the record was received, set by receiver
	TimeReceived         string   `protobuf:"bytes,5,opt,name=timeReceived,proto3" json:"timeReceived,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Record) Reset()         { *m = Record{} }
func (m *Record) String() string { return proto.CompactTextString(m) }
func (*Record) ProtoMessage()    {}
func (*Record) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b4b639837d62b3e, []int{2}
}
func (m *Record) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Record) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Record.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Record) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Record.Merge(m, src)
}
func (m *Record) XXX_Size() int {
	return m.Size()
}
func (m *Record) XXX_DiscardUnknown() {
	xxx_messageInfo_Record.DiscardUnknown(m)
}

var xxx_messageInfo_Record proto.InternalMessageInfo

func (m *Record) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Record) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Record) GetTimeReceived() string {
	if m != nil {
		return m.TimeReceived
	}
	return ""
}

type TableIndex struct {
	Level                int32    `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	Min                  *Key     `protobuf:"bytes,2,opt,name=min,proto3" json:"min,omitempty"`
	Max                  *Key     `protobuf:"bytes,3,opt,name=max,proto3" json:"max,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TableIndex) Reset()         { *m = TableIndex{} }
func (m *TableIndex) String() string { return proto.CompactTextString(m) }
func (*TableIndex) ProtoMessage()    {}
func (*TableIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b4b639837d62b3e, []int{3}
}
func (m *TableIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableIndex.Merge(m, src)
}
func (m *TableIndex) XXX_Size() int {
	return m.Size()
}
func (m *TableIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_TableIndex.DiscardUnknown(m)
}

var xxx_messageInfo_TableIndex proto.InternalMessageInfo

func (m *TableIndex) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *TableIndex) GetMin() *Key {
	if m != nil {
		return m.Min
	}
	return nil
}

func (m *TableIndex) GetMax() *Key {
	if m != nil {
		return m.Max
	}
	return nil
}

type FindNodeRequest struct {
	Key                  *Key          `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	MV                   []byte        `protobuf:"bytes,2,opt,name=MV,proto3" json:"MV,omitempty"`
	ClosestIndex         *TableIndex   `protobuf:"bytes,3,opt,name=closestIndex,proto3" json:"closestIndex,omitempty"`
	NeighborListIndex    []*TableIndex `protobuf:"bytes,4,rep,name=neighborListIndex,proto3" json:"neighborListIndex,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *FindNodeRequest) Reset()         { *m = FindNodeRequest{} }
func (m *FindNodeRequest) String() string { return proto.CompactTextString(m) }
func (*FindNodeRequest) ProtoMessage()    {}
func (*FindNodeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b4b639837d62b3e, []int{4}
}
func (m *FindNodeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FindNodeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FindNodeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FindNodeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindNodeRequest.Merge(m, src)
}
func (m *FindNodeRequest) XXX_Size() int {
	return m.Size()
}
func (m *FindNodeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FindNodeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FindNodeRequest proto.InternalMessageInfo

func (m *FindNodeRequest) GetKey() *Key {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *FindNodeRequest) GetMV() []byte {
	if m != nil {
		return m.MV
	}
	return nil
}

func (m *FindNodeRequest) GetClosestIndex() *TableIndex {
	if m != nil {
		return m.ClosestIndex
	}
	return nil
}

func (m *FindNodeRequest) GetNeighborListIndex() []*TableIndex {
	if m != nil {
		return m.NeighborListIndex
	}
	return nil
}

// designed to be used in all protocols
type MessageData struct {
	Version   string           `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	Type      MessageType      `protobuf:"varint,2,opt,name=type,proto3,enum=ayame.pb.MessageType" json:"type,omitempty"`
	Timestamp int64            `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Id        string           `protobuf:"bytes,4,opt,name=id,proto3" json:"id,omitempty"`
	Req       *FindNodeRequest `protobuf:"bytes,5,opt,name=req,proto3" json:"req,omitempty"`
	// Used to specify the key associated with this message (may be a range in multicast)
	Key *Key `protobuf:"bytes,6,opt,name=key,proto3" json:"key,omitempty"`
	// Used to specify the MV associated with this message
	Mv []byte `protobuf:"bytes,7,opt,name=mv,proto3" json:"mv,omitempty"`
	// protocol specific data added by author (such as level info)
	AuthorAppData string `protobuf:"bytes,8,opt,name=authorAppData,proto3" json:"authorAppData,omitempty"`
	// peer information of the node who created the message
	Author *Peer `protobuf:"bytes,9,opt,name=author,proto3" json:"author,omitempty"`
	// the Secp256k1 public key (32bytes)
	AuthorPubKey []byte `protobuf:"bytes,10,opt,name=authorPubKey,proto3" json:"authorPubKey,omitempty"`
	// signature of message by authoring node (except authorSign and senderAppData)
	AuthorSign []byte `protobuf:"bytes,11,opt,name=authorSign,proto3" json:"authorSign,omitempty"`
	// protocol specific data added by sender (such as level info)
	SenderAppData string `protobuf:"bytes,12,opt,name=senderAppData,proto3" json:"senderAppData,omitempty"`
	// Used to return peers closer to a key in FIND_NODE
	CloserPeers []*Peer `protobuf:"bytes,13,rep,name=closerPeers,proto3" json:"closerPeers,omitempty"`
	// Used to include candidate peers in FIND_NODE
	CandidatePeers []*Peer `protobuf:"bytes,14,rep,name=candidatePeers,proto3" json:"candidatePeers,omitempty"`
	// used to include path in UNICAST
	Path []*Peer `protobuf:"bytes,15,rep,name=path,proto3" json:"path,omitempty"`
	// the record used to deliver in this message
	Record               *Record  `protobuf:"bytes,16,opt,name=record,proto3" json:"record,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageData) Reset()         { *m = MessageData{} }
func (m *MessageData) String() string { return proto.CompactTextString(m) }
func (*MessageData) ProtoMessage()    {}
func (*MessageData) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b4b639837d62b3e, []int{5}
}
func (m *MessageData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageData.Merge(m, src)
}
func (m *MessageData) XXX_Size() int {
	return m.Size()
}
func (m *MessageData) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageData.DiscardUnknown(m)
}

var xxx_messageInfo_MessageData proto.InternalMessageInfo

func (m *MessageData) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *MessageData) GetType() MessageType {
	if m != nil {
		return m.Type
	}
	return MessageType_PUT_VALUE
}

func (m *MessageData) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *MessageData) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *MessageData) GetReq() *FindNodeRequest {
	if m != nil {
		return m.Req
	}
	return nil
}

func (m *MessageData) GetKey() *Key {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *MessageData) GetMv() []byte {
	if m != nil {
		return m.Mv
	}
	return nil
}

func (m *MessageData) GetAuthorAppData() string {
	if m != nil {
		return m.AuthorAppData
	}
	return ""
}

func (m *MessageData) GetAuthor() *Peer {
	if m != nil {
		return m.Author
	}
	return nil
}

func (m *MessageData) GetAuthorPubKey() []byte {
	if m != nil {
		return m.AuthorPubKey
	}
	return nil
}

func (m *MessageData) GetAuthorSign() []byte {
	if m != nil {
		return m.AuthorSign
	}
	return nil
}

func (m *MessageData) GetSenderAppData() string {
	if m != nil {
		return m.SenderAppData
	}
	return ""
}

func (m *MessageData) GetCloserPeers() []*Peer {
	if m != nil {
		return m.CloserPeers
	}
	return nil
}

func (m *MessageData) GetCandidatePeers() []*Peer {
	if m != nil {
		return m.CandidatePeers
	}
	return nil
}

func (m *MessageData) GetPath() []*Peer {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *MessageData) GetRecord() *Record {
	if m != nil {
		return m.Record
	}
	return nil
}

type Message struct {
	Data *MessageData `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	// signature of message by sender node
	SenderSign []byte `protobuf:"bytes,2,opt,name=senderSign,proto3" json:"senderSign,omitempty"`
	// peer information of the node who sent the message
	Sender               *Peer    `protobuf:"bytes,3,opt,name=sender,proto3" json:"sender,omitempty"`
	IsRequest            bool     `protobuf:"varint,4,opt,name=isRequest,proto3" json:"isRequest,omitempty"`
	IsResponse           bool     `protobuf:"varint,5,opt,name=isResponse,proto3" json:"isResponse,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b4b639837d62b3e, []int{6}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetData() *MessageData {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Message) GetSenderSign() []byte {
	if m != nil {
		return m.SenderSign
	}
	return nil
}

func (m *Message) GetSender() *Peer {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *Message) GetIsRequest() bool {
	if m != nil {
		return m.IsRequest
	}
	return false
}

func (m *Message) GetIsResponse() bool {
	if m != nil {
		return m.IsResponse
	}
	return false
}

func init() {
	proto.RegisterEnum("ayame.pb.KeyType", KeyType_name, KeyType_value)
	proto.RegisterEnum("ayame.pb.ConnectionType", ConnectionType_name, ConnectionType_value)
	proto.RegisterEnum("ayame.pb.MessageType", MessageType_name, MessageType_value)
	proto.RegisterType((*Key)(nil), "ayame.pb.Key")
	proto.RegisterType((*Peer)(nil), "ayame.pb.Peer")
	proto.RegisterType((*Record)(nil), "ayame.pb.Record")
	proto.RegisterType((*TableIndex)(nil), "ayame.pb.TableIndex")
	proto.RegisterType((*FindNodeRequest)(nil), "ayame.pb.FindNodeRequest")
	proto.RegisterType((*MessageData)(nil), "ayame.pb.MessageData")
	proto.RegisterType((*Message)(nil), "ayame.pb.Message")
}

func init() { proto.RegisterFile("ayame.proto", fileDescriptor_7b4b639837d62b3e) }

var fileDescriptor_7b4b639837d62b3e = []byte{
	// 877 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x55, 0xcd, 0x6e, 0xeb, 0x54,
	0x10, 0xae, 0x7f, 0xe2, 0x24, 0x93, 0x9f, 0x9e, 0x1e, 0x15, 0xc9, 0x48, 0x28, 0x44, 0x16, 0xa0,
	0x50, 0xa4, 0x0a, 0x15, 0x09, 0xdd, 0x25, 0xb9, 0x71, 0x5a, 0x59, 0x4d, 0x9c, 0xe8, 0xd4, 0x0d,
	0xcb, 0xca, 0x89, 0x47, 0xad, 0x45, 0x62, 0xe7, 0xda, 0x6e, 0xd4, 0xbc, 0x09, 0x4b, 0xf6, 0xbc,
	0x01, 0x2b, 0x96, 0xac, 0x10, 0x8f, 0x80, 0xca, 0x8b, 0xa0, 0x73, 0x8e, 0x1d, 0x27, 0x6d, 0xe1,
	0xee, 0x3c, 0x33, 0xdf, 0xcc, 0x7c, 0x33, 0xe7, 0x9b, 0x04, 0x1a, 0xfe, 0xd6, 0x5f, 0xe1, 0xf9,
	0x3a, 0x89, 0xb3, 0x98, 0xd6, 0x72, 0x63, 0x6e, 0xfd, 0x00, 0xda, 0x35, 0x6e, 0xe9, 0x97, 0xa0,
	0x67, 0xdb, 0x35, 0x9a, 0x4a, 0x57, 0xe9, 0xb5, 0x2f, 0x4e, 0xce, 0x8b, 0xf8, 0xf9, 0x35, 0x6e,
	0xbd, 0xed, 0x1a, 0x99, 0x08, 0x53, 0x0a, 0xfa, 0x3c, 0x0e, 0xb6, 0xa6, 0xda, 0x55, 0x7a, 0x4d,
	0x26, 0xbe, 0xad, 0x5f, 0x15, 0xd0, 0xa7, 0x88, 0x09, 0x6d, 0x83, 0x1a, 0x06, 0xa2, 0x42, 0x9d,
	0xa9, 0x61, 0x40, 0x4f, 0xa1, 0xe2, 0x07, 0x41, 0x92, 0x9a, 0x6a, 0x57, 0xeb, 0x35, 0x99, 0x34,
	0xe8, 0x3b, 0x80, 0x45, 0x1c, 0x45, 0xb8, 0xc8, 0xc2, 0x38, 0x32, 0x35, 0xd1, 0xcf, 0x2c, 0xfb,
	0x0d, 0x76, 0x31, 0xd1, 0x76, 0x0f, 0x4b, 0x3f, 0x07, 0xed, 0x27, 0xdc, 0x9a, 0x7a, 0x57, 0xe9,
	0x35, 0x2e, 0x5a, 0x07, 0x14, 0x19, 0x8f, 0x70, 0x02, 0xab, 0x8d, 0x59, 0x11, 0xdc, 0xd4, 0xd5,
	0x86, 0xb3, 0x5d, 0x60, 0x92, 0x99, 0x86, 0x64, 0xcb, 0xbf, 0x2d, 0x0f, 0x0c, 0x86, 0x8b, 0x38,
	0x09, 0x28, 0x91, 0xe5, 0x14, 0x11, 0x14, 0xf9, 0xa7, 0x50, 0xd9, 0xf8, 0xcb, 0x47, 0xcc, 0xc7,
	0x93, 0x06, 0xb5, 0xa0, 0x99, 0x85, 0x2b, 0x64, 0xb8, 0xc0, 0x70, 0x83, 0x81, 0xa8, 0x5f, 0x67,
	0x07, 0x3e, 0x2b, 0x00, 0xf0, 0xfc, 0xf9, 0x12, 0x9d, 0x28, 0xc0, 0x27, 0x5e, 0x67, 0x89, 0x1b,
	0x5c, 0x8a, 0xda, 0x15, 0x26, 0x0d, 0x4e, 0x7f, 0x15, 0x46, 0xa2, 0xf6, 0x6b, 0xfa, 0xab, 0x50,
	0xcc, 0xb7, 0xf2, 0x9f, 0xc4, 0x4a, 0xde, 0x00, 0xf8, 0x4f, 0xd6, 0xef, 0x0a, 0x1c, 0x5f, 0x86,
	0x51, 0xe0, 0xc6, 0x01, 0x32, 0xfc, 0xf0, 0x88, 0x69, 0x56, 0x2c, 0x45, 0xf9, 0xbf, 0xa5, 0x8c,
	0x67, 0xf9, 0x44, 0xea, 0x78, 0x46, 0xdf, 0x41, 0x73, 0xb1, 0x8c, 0x53, 0x4c, 0x33, 0x41, 0x36,
	0x6f, 0x77, 0x5a, 0x66, 0x96, 0x83, 0xb0, 0x03, 0x24, 0x7d, 0x0f, 0x27, 0x11, 0x86, 0xf7, 0x0f,
	0xf3, 0x38, 0x19, 0x85, 0x45, 0xba, 0xde, 0xd5, 0xfe, 0x33, 0xfd, 0x35, 0xdc, 0xfa, 0x53, 0x87,
	0xc6, 0x18, 0xd3, 0xd4, 0xbf, 0x47, 0xdb, 0xcf, 0x7c, 0x6a, 0x42, 0x75, 0x83, 0x49, 0xca, 0xa5,
	0x20, 0x85, 0x53, 0x98, 0xf4, 0xeb, 0x5c, 0x91, 0xaa, 0x50, 0xc8, 0x27, 0x65, 0x83, 0x3c, 0x7d,
	0x4f, 0x95, 0x9f, 0x41, 0x9d, 0xbf, 0x46, 0x9a, 0xf9, 0xab, 0xb5, 0x98, 0x47, 0x63, 0xa5, 0x23,
	0x97, 0xa5, 0xbe, 0x93, 0xe5, 0x37, 0xa0, 0x25, 0xf8, 0x41, 0x3c, 0x63, 0xe3, 0xe2, 0xd3, 0xb2,
	0xee, 0x8b, 0xcd, 0x32, 0x8e, 0x2a, 0xd6, 0x6b, 0x7c, 0x44, 0x73, 0xd5, 0x9d, 0xe6, 0xbe, 0x80,
	0x96, 0xff, 0x98, 0x3d, 0xc4, 0x49, 0x7f, 0xbd, 0xe6, 0x13, 0x9a, 0x35, 0xd1, 0xf8, 0xd0, 0x49,
	0xbf, 0x02, 0x43, 0x3a, 0xcc, 0xba, 0xa8, 0xdc, 0x2e, 0x2b, 0xf3, 0x53, 0x62, 0x79, 0x94, 0x6b,
	0x4f, 0x7e, 0x4d, 0x1f, 0xe7, 0xd7, 0xb8, 0x35, 0x41, 0xf4, 0x39, 0xf0, 0xd1, 0x0e, 0x80, 0xb4,
	0x6f, 0xc2, 0xfb, 0xc8, 0x6c, 0x08, 0xc4, 0x9e, 0x87, 0x33, 0x4a, 0x31, 0x0a, 0x70, 0xc7, 0xa8,
	0x29, 0x19, 0x1d, 0x38, 0xe9, 0xb7, 0xd0, 0x10, 0x8f, 0x9d, 0xf0, 0xfe, 0xa9, 0xd9, 0x12, 0xcf,
	0xfa, 0x92, 0xd6, 0x3e, 0x84, 0x7e, 0x0f, 0xed, 0x85, 0x1f, 0x05, 0x61, 0xe0, 0x67, 0x28, 0x93,
	0xda, 0x6f, 0x26, 0xbd, 0x40, 0x51, 0x0b, 0xf4, 0xb5, 0x9f, 0x3d, 0x98, 0xc7, 0x6f, 0xa2, 0x45,
	0x8c, 0xf6, 0xc0, 0x48, 0xc4, 0x95, 0x9a, 0x44, 0xec, 0x87, 0x94, 0x28, 0x79, 0xbd, 0x2c, 0x8f,
	0x5b, 0xbf, 0x29, 0x50, 0xcd, 0x15, 0xc1, 0x25, 0x13, 0xf0, 0x01, 0xe5, 0x31, 0xbc, 0x96, 0x0c,
	0x1f, 0x94, 0x09, 0x08, 0x5f, 0x9a, 0x9c, 0x5f, 0x2c, 0x4d, 0x5e, 0xc7, 0x9e, 0x87, 0x3f, 0x90,
	0xb4, 0xf2, 0xfb, 0x78, 0xf5, 0x40, 0x32, 0xca, 0xa5, 0x17, 0xa6, 0xb9, 0x62, 0x84, 0xc6, 0x6a,
	0xac, 0x74, 0xf0, 0x2e, 0xdc, 0x48, 0xd7, 0x71, 0x94, 0xa2, 0x50, 0x5c, 0x8d, 0xed, 0x79, 0xce,
	0x1c, 0xa8, 0xe6, 0xbf, 0xaf, 0xb4, 0x0a, 0x9a, 0xe3, 0x7a, 0xe4, 0x88, 0xd6, 0xa1, 0x72, 0x39,
	0x9a, 0xf4, 0x3d, 0xa2, 0x50, 0x00, 0xe3, 0xc6, 0x63, 0x8e, 0x7b, 0x45, 0x54, 0x6a, 0x80, 0xea,
	0xd8, 0x44, 0xe3, 0x61, 0xd6, 0x77, 0xaf, 0x86, 0x44, 0xa7, 0x0d, 0xa8, 0xde, 0xba, 0xce, 0xa5,
	0x33, 0xb4, 0x49, 0xe5, 0xec, 0x47, 0x68, 0x1f, 0xfe, 0x74, 0xd2, 0x13, 0x68, 0xb9, 0x13, 0xef,
	0x6e, 0x30, 0x71, 0xdd, 0xe1, 0xc0, 0x1b, 0xda, 0xe4, 0x88, 0xb6, 0xa0, 0x5e, 0x9a, 0x0a, 0x3d,
	0x86, 0xc6, 0xa0, 0xef, 0x16, 0x08, 0xa2, 0x52, 0x0a, 0xed, 0x41, 0xdf, 0xdd, 0xcb, 0x22, 0xda,
	0xd9, 0x2f, 0xca, 0xee, 0x62, 0x45, 0xd9, 0x16, 0xd4, 0xa7, 0xb7, 0xde, 0xdd, 0xac, 0x3f, 0xba,
	0x1d, 0xca, 0x92, 0x57, 0xc3, 0xc2, 0x54, 0x28, 0x81, 0x66, 0xdf, 0xb6, 0xef, 0xa6, 0x6c, 0x32,
	0x73, 0xec, 0x21, 0x23, 0x2a, 0xa7, 0xc1, 0x01, 0x85, 0xe7, 0x86, 0x68, 0x3c, 0xe7, 0xd2, 0x71,
	0xed, 0x3b, 0x77, 0x62, 0xe7, 0x73, 0x08, 0x73, 0x3c, 0x23, 0x15, 0x5a, 0x03, 0x7d, 0xca, 0x27,
	0x36, 0x68, 0x13, 0x6a, 0xf6, 0x70, 0x24, 0x41, 0xd5, 0x7c, 0xd8, 0x41, 0xff, 0xc6, 0x23, 0x35,
	0x5e, 0x60, 0x7c, 0x3b, 0xf2, 0xa4, 0x59, 0x7f, 0x4f, 0xfe, 0x78, 0xee, 0x28, 0x7f, 0x3d, 0x77,
	0x94, 0xbf, 0x9f, 0x3b, 0xca, 0xcf, 0xff, 0x74, 0x8e, 0xe6, 0x86, 0xf8, 0x9b, 0xfb, 0xee, 0xdf,
	0x00, 0x00, 0x00, 0xff, 0xff, 0xf1, 0x1d, 0x60, 0x14, 0xf5, 0x06, 0x00, 0x00,
}

func (m *Key) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Key) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Key) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintAyame(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintAyame(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Peer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Peer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Peer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cert) > 0 {
		i -= len(m.Cert)
		copy(dAtA[i:], m.Cert)
		i = encodeVarintAyame(dAtA, i, uint64(len(m.Cert)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Mv) > 0 {
		i -= len(m.Mv)
		copy(dAtA[i:], m.Mv)
		i = encodeVarintAyame(dAtA, i, uint64(len(m.Mv)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAyame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Connection != 0 {
		i = encodeVarintAyame(dAtA, i, uint64(m.Connection))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Addrs) > 0 {
		for iNdEx := len(m.Addrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Addrs[iNdEx])
			copy(dAtA[i:], m.Addrs[iNdEx])
			i = encodeVarintAyame(dAtA, i, uint64(len(m.Addrs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintAyame(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Record) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Record) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Record) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TimeReceived) > 0 {
		i -= len(m.TimeReceived)
		copy(dAtA[i:], m.TimeReceived)
		i = encodeVarintAyame(dAtA, i, uint64(len(m.TimeReceived)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintAyame(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintAyame(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Max != nil {
		{
			size, err := m.Max.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAyame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Min != nil {
		{
			size, err := m.Min.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAyame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Level != 0 {
		i = encodeVarintAyame(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FindNodeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindNodeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FindNodeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NeighborListIndex) > 0 {
		for iNdEx := len(m.NeighborListIndex) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NeighborListIndex[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAyame(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ClosestIndex != nil {
		{
			size, err := m.ClosestIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAyame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MV) > 0 {
		i -= len(m.MV)
		copy(dAtA[i:], m.MV)
		i = encodeVarintAyame(dAtA, i, uint64(len(m.MV)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAyame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Record != nil {
		{
			size, err := m.Record.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAyame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.Path) > 0 {
		for iNdEx := len(m.Path) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Path[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAyame(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.CandidatePeers) > 0 {
		for iNdEx := len(m.CandidatePeers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CandidatePeers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAyame(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.CloserPeers) > 0 {
		for iNdEx := len(m.CloserPeers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CloserPeers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAyame(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.SenderAppData) > 0 {
		i -= len(m.SenderAppData)
		copy(dAtA[i:], m.SenderAppData)
		i = encodeVarintAyame(dAtA, i, uint64(len(m.SenderAppData)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.AuthorSign) > 0 {
		i -= len(m.AuthorSign)
		copy(dAtA[i:], m.AuthorSign)
		i = encodeVarintAyame(dAtA, i, uint64(len(m.AuthorSign)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.AuthorPubKey) > 0 {
		i -= len(m.AuthorPubKey)
		copy(dAtA[i:], m.AuthorPubKey)
		i = encodeVarintAyame(dAtA, i, uint64(len(m.AuthorPubKey)))
		i--
		dAtA[i] = 0x52
	}
	if m.Author != nil {
		{
			size, err := m.Author.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAyame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.AuthorAppData) > 0 {
		i -= len(m.AuthorAppData)
		copy(dAtA[i:], m.AuthorAppData)
		i = encodeVarintAyame(dAtA, i, uint64(len(m.AuthorAppData)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Mv) > 0 {
		i -= len(m.Mv)
		copy(dAtA[i:], m.Mv)
		i = encodeVarintAyame(dAtA, i, uint64(len(m.Mv)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAyame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Req != nil {
		{
			size, err := m.Req.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAyame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintAyame(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x22
	}
	if m.Timestamp != 0 {
		i = encodeVarintAyame(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintAyame(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintAyame(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsResponse {
		i--
		if m.IsResponse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.IsRequest {
		i--
		if m.IsRequest {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Sender != nil {
		{
			size, err := m.Sender.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAyame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SenderSign) > 0 {
		i -= len(m.SenderSign)
		copy(dAtA[i:], m.SenderSign)
		i = encodeVarintAyame(dAtA, i, uint64(len(m.SenderSign)))
		i--
		dAtA[i] = 0x12
	}
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAyame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAyame(dAtA []byte, offset int, v uint64) int {
	offset -= sovAyame(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Key) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAyame(uint64(m.Type))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovAyame(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Peer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAyame(uint64(l))
	}
	if len(m.Addrs) > 0 {
		for _, b := range m.Addrs {
			l = len(b)
			n += 1 + l + sovAyame(uint64(l))
		}
	}
	if m.Connection != 0 {
		n += 1 + sovAyame(uint64(m.Connection))
	}
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovAyame(uint64(l))
	}
	l = len(m.Mv)
	if l > 0 {
		n += 1 + l + sovAyame(uint64(l))
	}
	l = len(m.Cert)
	if l > 0 {
		n += 1 + l + sovAyame(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Record) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovAyame(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAyame(uint64(l))
	}
	l = len(m.TimeReceived)
	if l > 0 {
		n += 1 + l + sovAyame(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovAyame(uint64(m.Level))
	}
	if m.Min != nil {
		l = m.Min.Size()
		n += 1 + l + sovAyame(uint64(l))
	}
	if m.Max != nil {
		l = m.Max.Size()
		n += 1 + l + sovAyame(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FindNodeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovAyame(uint64(l))
	}
	l = len(m.MV)
	if l > 0 {
		n += 1 + l + sovAyame(uint64(l))
	}
	if m.ClosestIndex != nil {
		l = m.ClosestIndex.Size()
		n += 1 + l + sovAyame(uint64(l))
	}
	if len(m.NeighborListIndex) > 0 {
		for _, e := range m.NeighborListIndex {
			l = e.Size()
			n += 1 + l + sovAyame(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAyame(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovAyame(uint64(m.Type))
	}
	if m.Timestamp != 0 {
		n += 1 + sovAyame(uint64(m.Timestamp))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAyame(uint64(l))
	}
	if m.Req != nil {
		l = m.Req.Size()
		n += 1 + l + sovAyame(uint64(l))
	}
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovAyame(uint64(l))
	}
	l = len(m.Mv)
	if l > 0 {
		n += 1 + l + sovAyame(uint64(l))
	}
	l = len(m.AuthorAppData)
	if l > 0 {
		n += 1 + l + sovAyame(uint64(l))
	}
	if m.Author != nil {
		l = m.Author.Size()
		n += 1 + l + sovAyame(uint64(l))
	}
	l = len(m.AuthorPubKey)
	if l > 0 {
		n += 1 + l + sovAyame(uint64(l))
	}
	l = len(m.AuthorSign)
	if l > 0 {
		n += 1 + l + sovAyame(uint64(l))
	}
	l = len(m.SenderAppData)
	if l > 0 {
		n += 1 + l + sovAyame(uint64(l))
	}
	if len(m.CloserPeers) > 0 {
		for _, e := range m.CloserPeers {
			l = e.Size()
			n += 1 + l + sovAyame(uint64(l))
		}
	}
	if len(m.CandidatePeers) > 0 {
		for _, e := range m.CandidatePeers {
			l = e.Size()
			n += 1 + l + sovAyame(uint64(l))
		}
	}
	if len(m.Path) > 0 {
		for _, e := range m.Path {
			l = e.Size()
			n += 1 + l + sovAyame(uint64(l))
		}
	}
	if m.Record != nil {
		l = m.Record.Size()
		n += 2 + l + sovAyame(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovAyame(uint64(l))
	}
	l = len(m.SenderSign)
	if l > 0 {
		n += 1 + l + sovAyame(uint64(l))
	}
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovAyame(uint64(l))
	}
	if m.IsRequest {
		n += 2
	}
	if m.IsResponse {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAyame(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAyame(x uint64) (n int) {
	return sovAyame(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Key) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAyame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Key: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Key: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= KeyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAyame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAyame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Peer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAyame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Peer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Peer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addrs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addrs = append(m.Addrs, make([]byte, postIndex-iNdEx))
			copy(m.Addrs[len(m.Addrs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connection", wireType)
			}
			m.Connection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Connection |= ConnectionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &Key{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mv", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mv = append(m.Mv[:0], dAtA[iNdEx:postIndex]...)
			if m.Mv == nil {
				m.Mv = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cert = append(m.Cert[:0], dAtA[iNdEx:postIndex]...)
			if m.Cert == nil {
				m.Cert = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAyame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAyame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Record) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAyame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Record: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Record: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeReceived", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimeReceived = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAyame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAyame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAyame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Min == nil {
				m.Min = &Key{}
			}
			if err := m.Min.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Max == nil {
				m.Max = &Key{}
			}
			if err := m.Max.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAyame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAyame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindNodeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAyame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindNodeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindNodeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &Key{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MV", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MV = append(m.MV[:0], dAtA[iNdEx:postIndex]...)
			if m.MV == nil {
				m.MV = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosestIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClosestIndex == nil {
				m.ClosestIndex = &TableIndex{}
			}
			if err := m.ClosestIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeighborListIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NeighborListIndex = append(m.NeighborListIndex, &TableIndex{})
			if err := m.NeighborListIndex[len(m.NeighborListIndex)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAyame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAyame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAyame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Req", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Req == nil {
				m.Req = &FindNodeRequest{}
			}
			if err := m.Req.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &Key{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mv", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mv = append(m.Mv[:0], dAtA[iNdEx:postIndex]...)
			if m.Mv == nil {
				m.Mv = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorAppData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorAppData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Author == nil {
				m.Author = &Peer{}
			}
			if err := m.Author.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorPubKey = append(m.AuthorPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthorPubKey == nil {
				m.AuthorPubKey = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorSign", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorSign = append(m.AuthorSign[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthorSign == nil {
				m.AuthorSign = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderAppData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderAppData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloserPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloserPeers = append(m.CloserPeers, &Peer{})
			if err := m.CloserPeers[len(m.CloserPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CandidatePeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CandidatePeers = append(m.CandidatePeers, &Peer{})
			if err := m.CandidatePeers[len(m.CandidatePeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = append(m.Path, &Peer{})
			if err := m.Path[len(m.Path)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Record", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Record == nil {
				m.Record = &Record{}
			}
			if err := m.Record.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAyame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAyame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAyame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &MessageData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderSign", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderSign = append(m.SenderSign[:0], dAtA[iNdEx:postIndex]...)
			if m.SenderSign == nil {
				m.SenderSign = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAyame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAyame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &Peer{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRequest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRequest = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsResponse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsResponse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAyame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAyame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAyame(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAyame
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAyame
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAyame
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAyame
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAyame
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAyame        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAyame          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAyame = fmt.Errorf("proto: unexpected end of group")
)
